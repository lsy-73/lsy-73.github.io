[{"content":"首先我们写一个报oom错误的代码\npublic class demo01 { public static void main(String[] args) { byte[] array=new byte[1*1024*1024];//1m 1兆 ArrayList\u0026lt;demo01\u0026gt; list=new ArrayList\u0026lt;demo01\u0026gt;(); int count=0;//计数 try{ while(true){ list.add(new demo01());//无限的向list中添加数据，new新的对象。注意：次方法会导致oom count=count++; } }catch(Error e){ System.out.println(\u0026#34;count:\u0026#34;+count); e.printStackTrace(); } //Throwable //error //Exception } } 设置堆内存大小 如果不设置堆内存，堆的默认内存应该是1GB，会占用很多资源，为了让   解释一下-XX:+HeapDumpOnOutOfMemoryError\n heap表示堆，on表示条件\n让堆进行Dump，条件是OutOfMemoryError。意思就是说只要报出OOM这个异常，就会被Dump\n如果要dump其他异常只需要将OutOfMemoryError这个异常改成你想要的dump的异常就可以了\n Jprofiler查看内存使用情况 上一步我们设置完堆内存大小后，在运行一下程序，如下：会创建一个文件Dumping heap to java_pid47550.hprof \u0026hellip;。  \n此时我们找到这个文件：\n 依次点击：对着demo01类右击\u0026gt;open in\u0026gt;finder\u0026gt;在文件根目录下就可以找到Dumping heap to java_pid47550.hprof这个文件,然后双击打开（前提是下载了jprofiler这个软件）\n  Jprofiler  如上图我们可以在最大对象这里看出是那个部分出错，如果具体要看是哪一行有问题，我们需要点击堆遍历器下的线程转储，这样就可以看出问题所在了\nJVM常见调优  堆设置\n -Xms:初始堆大小 -Xmx:最大堆大小 -XX:NewSize=n:设置年轻代大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxPermSize=n:设置持久代大小  收集器设置\n -XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器 -XX:+UseParalledlOldGC:设置并行年老代收集器 -XX:+UseConcMarkSweepGC:设置并发收集器  垃圾回收统计信息\n -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename  并行收集器设置\n -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 ","date":"2022-04-24T20:10:48+08:00","image":"/archives/jprofiler%E7%9A%84%E4%BD%BF%E7%94%A8/1_huceec11a37ce81c6fc2bf176abd04b78c_215500_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/jprofiler%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Jprofiler的使用"},{"content":"java类加载器 首先，我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在Java中，类加载器有很多，那么当JVM想要加载一个.class文件的时候，到底应该由哪个类加载器加载呢？\n首先，我们需要知道的是，Java语言系统中支持以下4种类加载器：\nBootstrap ClassLoader (启动类加载器)\n默认加载的是jdk\\lib目录下jar中诸多类；\n这个路径可以使用 -Xbootclasspath参数指定。\nExtension ClassLoader (扩展类加载器)\n默认加载jdk\\lib\\ext\\目录下jar中诸多类；\n这个路径可以使用 java.ext.dirs系统变量来更改。\nApplication ClassLoader (应用程序类加载器)\n负责加载开发人员所编写的诸多类。\nUser ClassLoader (自定义类加载器)\n当存在上述类加载器解决不了的特殊情况，或存在特殊要求时，可以自行实现类加载逻辑。\n关系如图所示：  类加载器关系图 \n什么是双亲委派 其是在JDK1.2期间被引入的，而后陆续被推荐给开发者，到目前已经成为了最常用的类加载器实现方式了。 双亲委派整个过程分为以下几步：\n  假设用户刚刚摸鱼写的Test类想进行加载，这个时候首先会发送给应用程序类加载器AppCloassLoader；\n  然后AppClassLoader并不会直接去加载Test类，而是会委派于父类加载器完成此操作，也就是ExtClassLoader；\n  ExtClassLoader同样也不会直接去加载Test类，而是会继续委派于父类加载器完成，也就是BootstrapClassLoader；\n  BootstrapClassLoader这个时候已经到顶层了，没有父类加载器了，所以BootstrapClassLoader会在jdk/lib目录下去搜索是否存在，因为这里是用户自己写的Test类，是不会存在于jdk下的，所以这个时候会给子类加载器一个反馈。\n  ExtClassLoader收到父类加载器发送的反馈，知道了父类加载器并没有找到对应的类，爸爸靠不住，就只能自己来加载了，结果显而易见，自己也不行，没办法，只能给更下面的子类加载器了。\n  AppClassLoader收到父类加载器的反馈，顿时明白，原来爸爸虽然是爸爸，但是他终究不能管儿子的私事，所以这时候，AppClassLoader就自己尝试去加载。\n 总结：就是一个类从应用类加载器（Application ClassLoader）进入，会不断的向上找类加载器直到找到类加载器的顶层-\u0026gt;启动类加载器（BootstrapClassLoader）,然后查看有没有对应的类，如果没有就交给子类去加载。\n 为什么需要双亲委派机制 使用双亲委派模型，有一个很大的好处，就是避免原始类被覆盖的问题。\n比如，用户编写了一个Object类，放入程序中加载。\n当没有双亲委派机制时，就会出现重复的Object类，会给开发人员造成很大的困扰，本来就只需要基于JDK开发就好了，现在还得把JDK中的类全记住，避免编写重复的类。\n当存在双亲委派机制时呢，整个事情就不一样了，每次加载类时，都会遵循双亲委派机制，去问父类是否可以加载，如果可以呢，那就不需要再次加载了，这样事情就变得简单了。（老子走的路，小子不能走 ）\n另外，通过双亲委派的方式，还保证了安全性。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。\n那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。\n 总结：1.避免类的重复加载\n2.防止核心类被篡改\n 如何主动破坏双亲委派机制？ 首先看一下loadclass的源码：\nprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //首先检查类是否已经被加载过了 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); //若父加载器为空则默认使用启动类加载器作为父加载器 if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // 如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。 } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 看过源码我们知道了双亲委派模型的实现，那么想要破坏双亲委派机制就很简单了。\n因为他的双亲委派过程都是在loadClass方法中实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。\n 总结：重写loadclass方法\n ","date":"2022-04-24T20:09:28+08:00","image":"/archives/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/1_hu124c772b1b7dfb7979e375944d922698_71386_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","title":"双亲委派机制"},{"content":"什么是本地方法Native？  简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以extern“C”告知C++编译器去调用一个C的函数。\n凡是带了Native关键字的，说明java的作用范围达不到了，会去调用底层c语言的库！\n “A native method is a Java method whose implementation is provided by non-java code.”\n 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。\n举例\n如果要启动一个线程\nnew Thread.start(); 在start（）方法源码中\npublic synchronized void start() { if (threadStatus != 0)//状态校验 0：NEW 新建状态 throw new IllegalThreadStateException(); group.add(this);//添加进线程组 boolean started = false; try { start0();//调用native方法执行线程run方法 started = true; } finally { try { if (!started) { group.threadStartFailed(this);//启动失败，从线程组中移除当前前程。 } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); 进入start方法后，检查如果状态不为0，后将它添加到group组中，然后调用了一个start0（）方法，但是private native void start0(); 这个方法放在一个class会很奇怪吧。因为这是线程级别的东西，java处理不了然后去调用c++底层\n下面这张图：\n  java虚拟机在操作系统之上，那操作系统的东西java是调用不了的，所以只能使用接口去调用本地方法，那调用本地方法库就需要使用到native\n为什么要使用Native Method？  Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n1.与java环境外交互：\n 有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。\n 你可以想想java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。\n2.与操作系统交互：\n JVM支持着Java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\n3.Sun\u0026rsquo;s Java\n Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。\nNative调用流程  \n本地方法接口（Java Native Interface）简称：JNI\n第一步：凡是带了Native关键字的，说明java的作用范围达不到了，会去调用底层c语言的库！\n第二步：进入本地方法栈区\n第三步：调用本地方法接口JNI\n JNI的作用:扩展java的使用，融合不同的语言为java所用 例如java调用python，c++等，都可以使用JNI\n 那JNI为什么会诞生？\n 因为java刚刚诞生的时候c和C++很流行，想要立足那必须要有可以调用c和c++程序\n 一般在哪使用到Native？ 一般在做硬件方面的东西或者java程序驱动打印机，管理系统，robot（）机器人类\n","date":"2022-04-22T16:57:19+08:00","image":"/archives/jvm-native/1_hu3d03a01dcc18bc5be0e67db3d8d209a6_2551496_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/jvm-native/","title":"JVM Native"},{"content":"时间复杂度和空间复杂度是衡量算法优劣的标准，效率可以用算法的时间复杂度来描述，而所占用的存储空间可以用算法的空间复杂度来描述。\n 时间复杂度：用于评估执行程序所消耗的时间，可以估算出程序对处理器的使用程度。 空间复杂度：用于评估执行程序所占用的内存空间，可以估算出程序对计算机内存的使用程度。  常见的时间复杂度有：O(1)常数型；O(log n)对数型，O(n)线性型，O(nlog n)线性对数型，O(n2)平方型，O(n3)立方型，O(nk)k次方型，O(2n)指数型。\n \n值得留意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效。这要添加上问题规模n的范围，在一定问题规范范围之前某一算法比另外一算法高效，而过了一个阈值之后，情况可能就相反了，通过上图我们可以明显看到这一点。这也就是为什么我们在实践的过程中得出的结论可能上面算法的排序相反的原因。\n如何推导时间复杂度 求解算法复杂度一般分以下几个步骤：\n 找出算法中的基本语句：算法中执行次数最多的语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级：只需计算基本语句执行次数的数量级，即只要保证函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，使注意力集中在最重要的一点上：增长率。 用大Ο表示算法的时间性能：将基本语句执行次数的数量级放入大Ο记号中。 其中用大O表示法通常有三种规则：  用常数1取代运行时间中的所有加法常数；\n 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数； 下面通过具体的实例来说明以上的推断步骤和规则。  时间复杂度实例 常数阶O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：\nint i = 1; int j = 2; int k = 1 + 2; 上述代码执行时，单个语句的频度均为1，不会随着问题规模n的变化而变化。因此，算法时间复杂度为常数阶，记作T(n)=O(1)。这里我们需要注意的是，即便上述代码有成千上万行，只要执行算法的时间不会随着问题规模n的增长而增长，那么执行时间只不过是一个比较大的常数而已。此类算法的时间复杂度均为O(1)。\n对数阶O(log n) 先来看对应的示例代码:\nint i = 1; // ① while (i \u0026lt;= n) { i = i * 2; // ② } 在上述代码中，语句①的频度为1，可以忽略不计。\n语句②我们可以看到它是以2的倍数来逼近n，每次都乘以2。如果用公式表示就是122*2…*2 \u0026lt;=n，也就是说2的x次方小于等于n时会执行循环体，记作2^x \u0026lt;= n，于是得出x\u0026lt;=logn。也就是说上述循环在执行logn次之后，便结束了，因此上述代码的时间复杂度为O(log n)。\n其实上面代码的时间复杂度公式如果精确的来讲应该是：T(n) = 1 + O(log n)，但我们上面已经讲到对应的原则，“只保留时间函数中的最高阶项”，因此记作O(log n)。\n线性阶O(n) 示例代码：\nint j = 0; // ① for (int i = 0; i \u0026lt; n; i++) { // ② j = i; // ③ j++; // ④ } 上述代码中，语句①的频度为1，②的频度为n，③的频度为n-1，④的频度为n-1，因此整个算法可以用公式T(n)=1+n+(n-1)+(n-1)来表示。进而可以推到T(n)=1+n+(n-1)+(n-1)=3n-1，即O(n)=3n-1，去掉低次幂和系数即O(n)=n，因此T(n)=O(n)。\n在上述代码中for循环中的代码会执行n遍，因此它消耗的时间是随着n的变化而成线性变化的，因此这类算法都可以用O(n)来表示时间复杂度。\n线性对数阶O(nlogN) 示例代码：\nfor (int m = 1; m \u0026lt; n; m++) { int i = 1; // ① while (i \u0026lt;= n) { i = i * 2; // ② } } 线性对数阶要对照对数阶 O(log n)来进行理解。上述代码中for循环内部的代码便是上面讲到对数阶，只不过在对数阶的外面套了一个n次的循环，当然，它的时间复杂度就是n*O(log n)了，于是记作O(nlog n)。\n平方阶O(n²) 示例代码:\nint k = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { k++; } } 平方阶可对照线性阶来进行理解，我们知道线性阶是一层for循环，记作O(n)，此时等于又嵌套了一层for循环，那么便是n * O(n)，也就是O(n * n)，即O(n^2)。\n如果将外层循环中的n改为m，即：\nint k = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { k++; } } 那么，对应的时间复杂度便为：O(m * n)。\n同理，立方阶O(n³)、K次方阶O(n^k)，只不过是嵌套了3层循环、k层循环而已。\n空间复杂度 最后，我们再了解一下空间复杂度。空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量，这里的空间复杂度同样是预估的。\n程序执行除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间。存储空间通常包括：指令空间（即代码空间）、数据空间（常量、简单变量）等所占的固定部分和动态分配、递归栈所需的可变空间。其中可变空间与算法有关。\n一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))其中n为问题的规模，S(n)表示空间复杂度。\n空间复杂度实例 空间复杂度 O(1) 空间复杂度为O(1)的情况的示例代码与时间复杂度为O(1)的实例代码一致：\nint i = 1; int j = 2; int k = 1 + 2; 上述代码中临时空间并不会随着n的变化而变化，因此空间复杂度为O(1)。总结一下就是：如果算法执行所需要的临时空间不随着某个变量n的大小而变化，此算法空间复杂度为一个常量，可表示为 O(1)，即 S(n) = O(1)。\n空间复杂度 O(n) 示例代码：\nint j = 0; int[] m = new int[n]; for (int i = 1; i \u0026lt;= n; ++i) { j = i; j++; } 上述代码中，只有创建int数组分配空间时与n的大小有关，而for循环内没有再分配新的空间，因此，对应的空间复杂度为S(n) = O(n)。\n总结：\n本篇文章给大家讲了可以通过时间复杂度和空间复杂度来衡量算法的优劣，同时用具体的实例来讲解如何计算不同方法的时间复杂度和空间复杂度。\n参考：\nhttps://blog.csdn.net/zolalad/article/details/11848739\n","date":"2022-04-08T13:51:19+08:00","image":"/archives/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/2_hufa17463cd2f8fec8fc68f7767c4d536f_109577_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"时间与空间复杂度"},{"content":"关于快慢指针 怎么证明快慢指针在环中是可以相遇的？ 证明这个问题？可能你会说，只要快慢两个指针都进入环中，两者有速度差，快指针就一定能够追上慢指针。可是这儿“追上”有可能是两种情况（注意，这儿讨论的是一般情况，快指针步长k \u0026gt;= 2），一是恰好追上（也就是相遇了），二是追上并超过了慢指针。当然，这两种情况都不妨碍我们判断是否有环存在。下面我们就证明一下无论快指针步长k为多少，快慢指针在环中都能恰好相遇。\n证明开始：\n方法一：  链表图 \n首先，换个角度想问题。用一个步长为1的指针模拟遍历这个单向链表的过程。如上图所示，设单向链表的起始结点为X0（0是下标），环的起始结点为Xs。自然，遍历到最后就是一遍遍的重复这个环。如果，我们把遍历的项都不断记录到一个数组中的话(下标按次序递增)，最后就是一定长度的序列串的重复。例如，\nX0, X1, \u0026hellip; , Xs, Xs+1, \u0026hellip;, Xs+cl-1\n​ Xs+cl, Xs+cl+1, \u0026hellip;, Xs+2*cl-1\n​ \u0026hellip;\ncl (circle length)表示环的长度。\n假设 j 是 cl 的整数倍，并且是 cl 整数倍中满足 j \u0026gt; s 最小的那个数。对于任意的 k (k \u0026gt;= 2)，我们考虑下标分别为 j 和 jk 的两个位置 Xj 和 Xjk。可见，Xj 就是慢指针走了 j 步之后的位置，而 j \u0026gt; s 则保证了此时慢指针已经进入环中。同理，此时的快指针在位置 Xjk，必然也在环中。\n因为 j 是 cl 的整数倍，我们可以把 Xjk 看成是一个指针从位置 Xj 开始，走了 (k - 1) 次的 j 步。而每走 j 步，在单向链表的环中，其实又回到了 Xj 位置，因为 j 是 cl 的整数倍。所以我们有，Xj = Xjk 。这样，我们就证明了快慢指针肯定会恰好相遇的问题。\n为什么快指针步长要为 2 ？3，4，5可以吗 有了上面证明的基础，就不难发现 k 越小，所需的遍历次数就越少，因为给定一个带环的单向链表，j 的取值是确定的。所以，取 k ＝ 2。当然，除了 1 ，别的其他数都可以。\n正规一点儿的分析，如下：\n因为 j 是 cl 的整数倍，并且是 cl 整数倍中满足 j \u0026gt; s 最小的那个数。如果 s \u0026lt;= cl，那么 j = cl；如果 s \u0026gt; cl，那么 j \u0026lt; 2*s ，所以 j 的时间复杂度为 O(s + cl)。假设单向链表中结点的个数为 n，因为 s 和 cl 都是小于 n 的，所以 j = O(n) 。这是慢指针的时间复杂度，那么快指针的就是 O(nk) 。所以取 k = 2 ，可以最小化算法的运行时间。\n方法二(简单版)： 证明能相遇 假定环前节点有 x 个，环上节点有 y 个，快慢指针在环上分别走了 m，n 圈后相遇， 在环上相遇的位置为 z，用 i 表示慢指针在相遇的时候走了多少步。能有如下两表达式： x + my + z = 2*i + 1 x + ny + z = 1*i 两式相减 (m - n)y = (2-1)i + 1 说明 i+1 的值为环节点长度的倍数，即可相遇 为什么快指针步长要为 2 ？3，4，5可以吗 有了上面证明的基础，就不难发现 k 越小，所需的遍历次数就越少，因为给定一个带环的单向链表，j 的取值是确定的。所以，取 k ＝ 2。当然，除了 1 ，别的其他数都可以。\n正规一点儿的分析，如下：\n因为 j 是 cl 的整数倍，并且是 cl 整数倍中满足 j \u0026gt; s 最小的那个数。如果 s \u0026lt;= cl，那么 j = cl；如果 s \u0026gt; cl，那么 j \u0026lt; 2*s ，所以 j 的时间复杂度为 O(s + cl)。假设单向链表中结点的个数为 n，因为 s 和 cl 都是小于 n 的，所以 j = O(n) 。这是慢指针的时间复杂度，那么快指针的就是 O(nk) 。所以取 k = 2 ，可以最小化算法的运行时间。\n总结：取其他数可以，但每取大一倍数就得多走一圈，所以取2才是最优解。\n参考：\nhttps://blog.csdn.net/xgjonathan/article/details/18034825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai\n","date":"2022-04-07T14:20:13+08:00","image":"/archives/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/1_hu41d61907f311ce5b0ea210fd61a4a533_75291_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","title":"快慢指针"},{"content":"1. Java中的泛型是什么 ? 使用泛型的好处是什么? 原则是什么？ Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常。\nJava泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常。\n泛型，即“参数化类型”，把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊类型,把\u0026lt;数据类型\u0026gt;当作是参数一样传递\n好处,在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。\n2. Java的泛型是如何工作的 ? 什么是类型擦除 ? 　泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。\n//类型被擦除了，保留的是类型的上限，String的上限就是Object List list = strlist; ​ List\u0026lt;String\u0026gt; stringList2 = list; List\u0026lt;Integer\u0026gt; intList2 = list; //你也可以把它赋给Integer类型的集合，但是当你把这个集合当 //成Integer的集合操作的时候，依旧会抛出ClassCastException异常 ​ for (Integer i:intList2){//java.lang.ClassCastException System.out.println(i); } \n3. 什么是泛型中的限定通配符和非限定通配符 ? 限定通配符对类型进行了限制。有两种限定通配符，一种是\u0026lt;? extends T\u0026gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是\u0026lt;? super T\u0026gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面表示了非限定通配符，因为可以用任意类型来替代。\npublic class Animal { public static void main(String[] args) { ArrayList\u0026lt;Animal\u0026gt; animals=new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Cat\u0026gt; cats=new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;? extends Cat\u0026gt; miniCats=new ArrayList\u0026lt;\u0026gt;(); showAnimal(cats); showAnimal(miniCats); //showAnimal(animals); } //类型通配符的上限，要求该泛型的类型，只能是实参类型，或实参类型的子类类型。 //此处上限是Cat，包括MiniCat但是不包括Anmial的 public static void showAnimal(ArrayList \u0026lt;? extends Cat\u0026gt; list){ for (int i = 0; i \u0026lt; list.size(); i++) { Cat cat = list.get(i); System.out.println(cat); } } //要求该泛型的类型，只能是实参类型，或实参类型的父类类型。 //类型通配符的下限，要求只能是Cat或者是Cat的父类 public static void showAnimal2(List\u0026lt;? super Cat\u0026gt; list){ //增强for循环，用object类型的o接受，遍历list for (Object o : list) { System.out.println(o); } } } class Cat extends Animal{ } class MiniCat extends Animal{ } \n4.可以把List\u0026lt; String\u0026gt;传递给一个接受List \u0026lt; Object\u0026gt;参数的方法吗？ 　对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以List\u0026lt; String\u0026gt;应当可以用在需要List\u0026lt; Object\u0026gt;的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List\u0026lt; Object\u0026gt;可以存储任何类型的对象包括String, Integer等等，而List\u0026lt; String\u0026gt;却只能用来存储Strings。\n例一:\n//这里与 List\u0026lt;Object\u0026gt; objectList; List\u0026lt;String\u0026gt; stringList; objectList = stringList; //compilation error incompatible types 例二:\nList list = new ArrayList();//默认类型是Object list.add(\u0026#34;A123\u0026#34;); list.add(\u0026#34;B234\u0026#34;); list.add(\u0026#34;C345\u0026#34;); System.out.println(list); for(int i=0;i\u0026lt;list.size();i++){ //若要将list中的元素赋给String变量，需要进行类型 //转换compatible types错误，显示list.get(i)返回的是Object String str = (String) list.get(i); System.out.println(str); } ​ list.add(123); //因为类型是Object，我们可以把Integer类型或者其他数据类型的元素也加入list之中 System.out.println(list.get(3)); ​ for(int i=0;i\u0026lt;list.size();i++){ //String str = (String) list.get(i); //但是在这里会报错java.lang.ClassCastException， //我们不能直接将Integer类型的数据转换成String System.out.println(list.get(i).getClass()); } 如代码中所示，当我们定义了一个List，list默认的类型是所有对象的基类Object，那么我们取出数据的时候需要经过一次类型转换才能进行对象的实际类型的相关操作。因为List中的类型是Object，那么我们先添加了String类型的数据，然后再添加Integer或者其他类型的数据也是允许的，因为编译时List中是Object类型的数据，然而运行的时候却是它本身的类型，所以当我们将List中的数据当作String处理时会抛出java.lang.ClassCastException\n5. Array中可以用泛型吗? 　这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。\n本文参考：\nhttps://www.jb51.net/article/214509.htm\nhttps://cloud.tencent.com/developer/article/1033693\n","date":"2022-03-14T10:29:23+08:00","image":"/archives/%E6%B3%9B%E5%9E%8B/1_hu4e960fdb6340cae1ad375241e2cdb7c4_2583790_120x120_fill_box_smart1_3.png","permalink":"/archives/%E6%B3%9B%E5%9E%8B/","title":"泛型"},{"content":"GPG介绍 提到 GPG 不得不提一下 PGP(Pretty Good Privacy) ， PGP 最开始是由 Phil Zimmermann 开发，开发的目的是为了躲避监视，如果文件在网络上明文传输，那是多么危险。 PGP 虽然受很多人喜爱，但是是个商业软件，不能自由使用。所以自由基金会决定自己开发一个取名叫 GPG ，这就是 GPG 的由来。 GPG 和 PGP 都遵循 OpenPGP 加解密标准， 现在 PGP 被赛门铁克公司收购了。\n我们平时用各个网站免不了要记住密码，但如果都用一个那风险就很高，如果每个网站都不一样，那也记不住。通常的做法是把这些密码存到一个文件里，但是这个文件本身的安全我们没法保证，所以我们需要对这个文件进行加密。这就要用到我们今天的主角 GPG\n安装 安装就非常简单，没什么好说的，执行命令就完成了。我的是通过二进制文件下载的中文版，如果是brew下载应该是英文的，本文以英文版的为教程（中文的我就不多bb了）\nMac brew install gpg 生成密钥 现在我们通过 gpg --full-gen-key 来生成密钥。  密钥生成 \n Your selection? (选择要使用的加密算法),选1就行了\n  RSA keys may be between 1024 and 4096 bits long,(选择加密算法的长度，默认是2048，我选了最长的 4096)\n  Please specify how long the key should be valid.(选择密钥过期时间，如果是自己使用的话，可以选择永不过期，此处我选的0)\n  Real name:(输入用户名，不能少于5个字符，随便写自己喜欢的名字就行了)\n  Email address(输入自己的邮箱)\n  Comment:(这个可以不写，直接回车)\n  Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O(如果确认无误，输入 O)\n 通过上面的操作，生成了一个名为 lsygpg ，使用 RAS 算法加密，并且永不过期的账户。\n你如果不想选择加密算法和长度信息，可以使用 gpg --gen-key 来快速生成。这样生成的默认算法是 RAS ，有效时间是一年， comment 为空。\n生成撤销密钥 生成完密钥之后，为了保险起见，我们需要生成一个撤销证书，以便在日后我们不使用这个密钥的时候可以撤销。\n这个撤销只有你把公钥上传到公钥服务器才有效，如果你不上传到公钥服务器其实没多大作用。即便申请撤销了，它还是会存在，只是不建议使用了。\n撤销的命令如下\ngpg --gen-revoke test1 加密 有了密钥之后，我们来看看怎么用它来加密一个文件\n通过 gpg -r [uid] -o file -e file 来加密一个文件，其中 -r 指定用哪个用户加密， -o 表示加密后输出的文件， -e 表示要加密的文件。如果不用 -o 默认会在原来的文件后面添加 .gpg 的后缀，用来表示加密文件。\n举个例子：假设我们有一个 test.txt 的文件，内容如下\n我是帅哥 我们对其进行加密\ngpg -r test1 -e test.txt -- 可以使用 gpg -r test1 -o test.txt.gpg -e test.txt 效果是一样的 执行完成后会得到一个名为 test.txt.gpg 的文件，这个文件是一个二进制文件。\n如果我们想要显示 ASCII ，可以通过添加 -a 来显示\n 密钥生成 \n解密 加密完之后，我们来看如何解密\n通过 gpg -o file -d file 来对文件进行解密，其中 -o 表示解密后输出的文件，要放在前面， -d 表示要解密的文件。\n我们就拿之前加密的文件来进行解密\ngpg -o decrypt.txt -d test.txt.gpg cat decrypt.txt 我是帅哥 gpg -o decrypt.txt -d test.txt.asc cat decrypt.txt 我是帅哥 解密的时候会让你输入密码  密钥生成 \n签名 二进制签名 GPG除了可以用来加密，还可以用来签名，比如在 Github 上可以添加公钥来表示这个代码确实是你提交的。\n使用 gpg --sign test.txt 对 test.txt 进行签名，生成 test.txt.gpg ，里面的内容是二进制。\nASCII 签名 除了二进制的方式还可以输出 ASCII 的签名，用 gpg --clearsign test.txt 对 test.txt 进行 ASCII 签名\ngpg --clearsign test.txt cat test.txt.asc -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA256 This is gpg test -----BEGIN PGP SIGNATURE----- iQIzBAEBCAAdFiEEiPHq0DgY+8QbgkHmOxWoUusKglEFAl41jDIACgkQOxWoUusK glFEKhAAqwzhd4lexf1KyMTuCd5jAftPGB6AC1igmUx0gjpnMoZHv7gJkfFr8jTa iD958jXVY4fawsBQ+LEEkpJarBdZfY2No5Dw1PSlRlaUzCQgMkOPgLTdqGHuTNB0 /ENsIiweXv5kUXiSU1Paxedwi7yux5L34WWdi9Mg9KoLhJN84HEdzIKYZjJNyFtB WYP/Nqqqs01SBa3writrdVaj/ZaDqMtpzM9DSxfMT4P6NVDR3RGSTkQpnatEEa67 11i+oQXQcQT6a+O1vZ8GwbfoQ/EmPGT4nURs1HSEbAXj2aInquU5UjIvkvDp3q2x j9UbDBcQaQWQdAsuJItIfLeyY1BhejqVIjhPPFMhplp5XrHMMR+JJXOUJleQkkZV q35RitRlnRCjm+Z26aACS1vSS4Y23jaNV+MWv23OF570+iQ1lVotYLeLeMbuW4s9 oWQIqJydaePbL87wR3tTWm7OjlgZNrrSXh9aH366Oz5tjZVrZoJwNDupOj5uAgsf T58N0St0OlrPO2csUQw5Kkd7Ls1lKCkh+drPQEPHJJODzNo4WxjtPGwgwhIhLJcw o1TQxd3h5YhVInCs0XFzSx3Ty/Ds0Lm0zFa4AyINl0QiHkQy2OoD4rsFO7n6LdOk zJKrFEkSwuvTOeIBUOGulwZiZEFrxb9KpaCjhMLZgQfjSYAnyQ8= =lmwE -----END PGP SIGNATURE----- 这种方式会在源文件里加上签名。\n","date":"2022-01-31T13:42:39+08:00","image":"/archives/gpg%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%9B%E5%BB%BA/1_hu6953af31534abddeef4516176bce74a2_454934_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/gpg%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%9B%E5%BB%BA/","title":"GPG的使用与创建"},{"content":"前言 之前在购买 VPS 和域名时发现很多国外商家只支持 VISA，MASTERCARD 这两家的信用卡或者 PayPal，虽然国区 PayPal 可以绑定银联的借记卡/信用卡，但是除了这些以外我还有在 Google Play 购物的需求，未来也会有更多的境外支付的需要，目前我已经忍受不了每次去 Google Play 购物时都要先去淘宝买个礼品卡这个操作了，所以决定采用一个一劳永逸的办法：办理一张外币信用卡（准确来说是走非银联结算通道的信用卡）。我原本以为作为大学生办理一张外币信用卡会比较麻烦，不过想到之前在少数派看过《给普通大学生的境外支付指南》和《学生党 Google Play 剁手经验分享》，所以决定照此进行尝试。PS：本文都是我的个人经验分享，不一定完全有效，同时也可能具有时效性，仅作参考。\n大学生申请外币信用卡的方法 按照我的估计，很多大学生都没有考虑过申请信用卡，日常消费只需要借记卡绑定微信支付和支付宝就没问题了，有关于信用卡与借记卡的区别，是否应该申请信用卡，google 一下就能找到不少靠谱的回答，我就不多说了。不过大约十几年前大学生申请信用卡真的很难，由于申请信用卡时需要经过银行的资产审核，而大学生又没有工作，所以对于很多大学生来说是几乎不可能申请到信用卡。不过近年来已经有相当多的银行推出了大学生专属信用卡，上述的问题已经不复存在。然而别以为随便申请一张大学生信用卡就可以在 Google Play 之类的国外商店上购物了，想要在 Google Play 上购物，你需要一张非银联的信用卡（借记卡也行，但我只记得中国银行的 EMV 卡属于这一类）。注意，必须是非银联的卡，因为很多国外付款方式都不支持银联。除此以外，借记卡/信用卡还有单币/双币/全币的区别，只不过 VISA 和 MASTERCARD 基本上都是使用美元结算的，所以我们几乎不需要关心这个差别。在满足非银联的这个条件下，我们来选择一间银行的信用卡，参考学姿势的《大学生信用卡申请姿势》，里面对比了各个银行的大学生信用卡的区别，我们主要关注的是是否有 VISA 或 MasterCard 等非银联的卡，当然我也建议最好看下学姿势的其它文章，以后想要靠信用卡享受各种福利（俗称薅羊毛）的话可先要熟悉各家银行的信用卡的区别哦。\n以我申请的民生银行 more 世界卡为例，我先参考了《民生银行大学生信用卡申请指引》，然后通过民生银行官网进行申请（请注意是否为大学生版，大学生版是不需要填职业等信息的，如果不确定的话，点击学姿势的民生银行学术卡申请通道），在申请页面上如实填写必填的个人信息，在这当中，亲属手机号应该是最麻烦的，因为银行会根据这个手机号给你的家长发送短信，如果你的家长不同意你办信用卡，那么这里提供两个办法：\n1.假如你有一个手机号是你的家长的手机号的附属号码，那可以直接填这个手机号，然后在本人手机号填入一个使用自己的身份证注册的手机号。\n2.在家长的手机上设置短信骚扰拦截（每个国内 ROM 应该都有这个功能吧），根据短信内容设置关键字，短信的具体内容可看下方，例如可以设置拦截“民生银行”。\n 【民生银行】尊敬的A，您好！您的亲属B已向民生银行提交信用卡申请，我行预审通过，预计为其核发卡片的信用额度为5000.00元，具体申请事宜请您联系申请人核实。如您对本次申请存在异议，请于Y年M月D日24点前短信回复“QXSQ”，我行将终止本次申请。超过上述时间未回复则视为您同意本次申请。感谢您的支持！\n 搞定这些麻烦的申请步骤后，就是等待银行进行资料审核了。不出意外的话，大约一个星期后你就能收到通过信用卡申请的短信，假如不幸被拒的话，请回忆下自己是否填错了一些个人信息，或者之前是否曾有过欠钱没还的不良行为（例如花呗忘了还），或者学校不在某些银行的白名单当中。\n在发送短信告诉申请者通过信用卡申请后，银行会通过邮寄方式将信用卡寄给申请者，稍微等个两天，信用卡就到了！\n不过很可惜的是，刚到手的信用卡还不能被使用，需要进行激活后才可正常使用，有一些银行可以网上激活，然而民生银行是要求持卡人必须到柜台进行当面激活的，假如你在比较偏远的城市，这个就不太好办了。另外，我很想吐槽一下民生银行的初始信用卡密码设置手续，这 TM 居然需要我打电话进行设置，就完全没有考虑过安全性的问题吗？信用卡激活后，申请信用卡的整个过程总算是结束了，恭喜各位打开了新世界的大门。\n外币信用卡到手后 既然有了外币信用卡，那么很多国外商家的大门已经对我们敞开了。Google Play，美区 App Store，美区/日区亚马逊等商店都可以让我们疯狂剁手，还可以订阅 Spotify，Netflix 等流媒体服务。读到这里的读者可能都没有使用信用卡购物的经验，不过没关系，使用外币信用卡购物并不麻烦，一般而言只需填入信用卡卡号，CVC 码（信用卡背面的一个三位数），有效日期就可以了，以 Google Play 为例，说一下如何添加外币信用卡作为付款方式。\n在Google Play上添加外币信用卡作为付款方式 与申请信用卡相比，这节内容可以说是简单多了，直接根据图片操作即可（我已经添加了付款地址，如果之前尚未添加，那么在要求输入付款地址时可以随便输入相关信息，亲测姓名和地址等信息可以与信用卡上的信息不同；另外，确保信用卡里有大于等于 1 美元的余额/额度）：\n1.打开 Google Play，在侧边栏找到“付款方式”并点击\n 付款方式 \n2.点击“添加信用卡或借记卡”，按照要求输入信用卡卡号，CVC 码，有效日期（别填错了！！！）等\n 添加信用卡或借记卡 \n3.假如一切顺利的话，现在即可使用信用卡在 Google Play 上购买东西了，出现问题的话可参考《学生党 Google Play 剁手经验分享》中的“添加卡片并购物”一节进行解决，懒得与客服沟通的话可以先试着申请美区 PayPal 帐号，然后选择美区 PayPal 作为付款方式。\n一些小贴士 1.可以考虑使用外币信用卡申请美区 PayPal 帐号，使用 Paypal 付款更安全。 2.请善用 Google Play 中的心愿单功能，不急着买但想买的东西可放入心愿单中，等待打折，在黑色星期五的时候，很多 App 都会有幅度非常大的折扣。 3.外币信用卡建议设置自动购汇还款，一般在银行 App 中可设置此项，能免去每月手动购汇还款的麻烦，而且不用担心自己忘了还款。\n4.记得还款，各家银行的最后还款期限不尽相同，在每个月的最后还款期限前请确认一下自己是否已还款。\n5.再次强调，请注意用卡安全，信用卡背面的信息不要随便泄漏给别人。\n","date":"2021-12-17T00:00:00Z","image":"/archives/%E4%BD%9C%E4%B8%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%9A%84%E6%88%91%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E5%A4%96%E5%B8%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%B9%B6%E7%94%A8%E4%BA%8E%E5%A2%83%E5%A4%96%E6%94%AF%E4%BB%98/show_hua1e96627c79bb7cd39936a6d63fa6003_596890_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E4%BD%9C%E4%B8%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%9A%84%E6%88%91%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E5%A4%96%E5%B8%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%B9%B6%E7%94%A8%E4%BA%8E%E5%A2%83%E5%A4%96%E6%94%AF%E4%BB%98/","title":"作为大学生的我如何申请外币信用卡并用于境外支付"},{"content":"初始化 输入命令：\nmkdir \u0026lt;项目名称\u0026gt; cd \u0026lt;项目名称\u0026gt; #进入目录 git init #初始仓库，新建一个 .git 目录 ls -la #查看所有文件 touch \u0026lt;file1\u0026gt; #创建一个文件 mkdir \u0026lt;dir1\u0026gt; #新建一个目录 现在可以修改文件内容\ngit status -sb #文件前面有 ?? 号 git add . #一次性将文件添加到暂存区 git status -sb #现在文件前面 ?? 变成了 A git commit -m \u0026#34;xx\u0026#34; #将你 add 过的内容正式提交到本地仓库，并添加注释 git log #查看历史变动 文件变动 git status -sb git add . git commit -m \u0026#34;xx\u0026#34; 将本地仓库上传到 GitHub 新建一个空仓库，名称与本地目录名一致，复制ssh 不需要勾选任何东西\ngit remote add origin git@github.com:xxxx/\u0026lt;仓库名\u0026gt; git push -u origin master 更改文件内容 git add . git commit -m \u0026#34;xx\u0026#34; git push ","date":"2021-11-14T20:58:22+08:00","image":"/archives/%E4%BD%BF%E7%94%A8git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/p2_huf0460c7f5de3c9d4790db75b7f8c7413_373707_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E4%BD%BF%E7%94%A8git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","title":"使用git创建版本库"}]