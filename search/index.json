[{"content":"Spring：过滤器filter、拦截器interceptor、和AOP的区别与联系 Filter过滤器 过滤器拦截web访问url地址。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用Java的回调机制进行实现。 Filter过滤器：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。 过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)，并对请求响应做出像响应的过滤操作， 比如设置字符编码，鉴权操作等 Interceptor拦截器 *拦截器拦截以 .action结尾的url，拦截Action的访问*。 Interfactor是基于Java的反射机制（APO思想）进行实现，不依赖Servlet容器。 拦截器可以在方法执行之前(preHandle)和方法执行之后(afterCompletion)进行操作，回调操作(postHandle)，*可以获取执行的方法的名称*，请求(HttpServletRequest) Interceptor：可以控制请求的控制器和方法，但控制不了请求方法里的参数(*只能获取参数的名称，不能获取到参数的值*) **（**用于处理页面提交的请求响应并进行处理，例如做国际化，做主题更换，过滤等）。 Spring AOP拦截器 *只能拦截Spring管理Bean的访问（业务层Service）*。 具体AOP详情参照 Spring AOP：原理、 通知、连接点、切点、切面、表达式\n实际开发中，AOP常和事务结合：Spring的事务管理:声明式事务管理(切面)\nAOP操作可以对操作进行横向的拦截，最大的优势在于他可以获取执行方法的参数( ProceedingJoinPoint.getArgs() )，对方法进行统一的处理。\nAspect : 可以自定义切入的点，有方法的参数，\n但是拿不到http请求，可以通过其他方式如RequestContextHolder\n获得(\nServletRequestAttributes servletRequestAttributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); )。\n常见使用日志，事务，请求参数安全验证等\nSpring对AOP的支持 Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。\nSpring创建代理的规则为： 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB\nAOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：\n1、定义普通业务组件 2、定义切入点，一个切入点可能横切多个业务组件 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作\n所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理， 即：代理对象的方法=增强处理+被代理对象的方法。 Filter与Interceptor联系与区别 拦截器是基于java的反射机制，使用代理模式，而过滤器是基于函数回调。 拦截器不依赖servlet容器，过滤器依赖于servlet容器。 拦截器只能对action起作用，而过滤器可以对几乎所有的请求起作用（可以保护资源）。 拦截器可以访问action上下文，堆栈里面的对象，而过滤器不可以。 执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。 从上面对拦截器与过滤器的描述来看，它俩是非常相似的，都能对客户端发来的请求进行处理，它们的区别如下：\n作用域不同 过滤器依赖于servlet容器，只能在 servlet容器，web环境下使用 拦截器依赖于spring容器，可以在spring容器中调用，不管此时Spring处于什么环境 细粒度的不同 过滤器的控制比较粗，只能在请求进来时进行处理，对请求和响应进行包装 拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，也可以在渲染视图呈现给用户之后调用 中断链执行的难易程度不同 拦截器可以 preHandle方法内返回 false 进行中断 过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面 小结 简单总结一下，拦截器相比过滤器有更细粒度的控制，依赖于Spring容器，可以在请求之前或之后启动，过滤器主要依赖于servlet，过滤器能做的，拦截器基本上都能做。\nFilter、Interceptor、aop拦截方向和抛出异常方向图 参考（CV）：https://blog.csdn.net/fly910905/article/details/86537648\n","date":"2022-10-28T00:15:17+08:00","image":"/show.jpeg","permalink":"/archives/filter/","title":"Filter"},{"content":"富士c200 柯达金200 柯达400 ","date":"2022-05-25T10:14:38+08:00","image":"/archives/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%96%9C%E6%AC%A2%E7%9A%84%E8%83%B6%E7%89%87/show_hubc2de290ed5ba48e12b8dd7d5c065545_480974_120x120_fill_q75_box_smart1.jpeg","permalink":"/archives/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%96%9C%E6%AC%A2%E7%9A%84%E8%83%B6%E7%89%87/","title":"记录一些喜欢的胶片"},{"content":"破坏双重校验锁的单例 public Lazyman{ private Lazyman(){} private volatile static Lazyman lazyman; public static Lazyman getInstance3(){ if(lazyman==null){ synchronized (Lazyman.class){ if(lazyman==null){ lazyman=new Lazyman(); } } } return lazyman; } //使用反射破坏单例模式 public static void main(String[] args) throws Exception { Lazyman instance = Lazyman.getInstance3();//用单例模式创建 //用反射创建 Constructor\u0026lt;Lazyman\u0026gt; declaredConstructor=Lazyman.class.getDeclaredConstructor(null);//1。获取反射对象2。获得一个空参构造器 declaredConstructor.setAccessible(true);//无视私有的构造器(破除私有权限) Lazyman instance2=declaredConstructor.newInstance();//反射创建出来的对象 //查看用反射创建出来的对象和用单例模式创建出来的对象哈希值一不一样 System.out.println(instance); System.out.println(instance2); } } 运行后的结果：\ncom.java.Single.Lazyman@2503dbd3 com.java.Single.Lazyman@4b67cf4d 由结果可见单例确实被破坏了\n如何防止单例被破坏 declaredConstructor走了一个构造器Lazyman（），所以在Lazyman（）里加一个判断。加锁，第二次new的时候就会报错，如果Lazyman不为空，即已经创建过了，此时就知道是来搞破坏，所以抛出一个异常 破坏枚举单例 上一节我们说到枚举是绝对安全的，但是如果我们就想用反射破坏一下，下面来测试一下\n失败1:\n在EnumSingle.Class这个文件中我们看到里面有一个无参的构造方法，现在我们测试一下是否真的有无参构造 EnumSingle.Class public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { EnumSingle instance1=EnumSingle.INSTANCE; Constructor\u0026lt;EnumSingle\u0026gt; declaredconstructor= EnumSingle.class.getDeclaredConstructor(null); declaredconstructor.setAccessible(true); EnumSingle instance2=declaredconstructor.newInstance(); System.out.println(instance1); System.out.println(instance2); } } 此时爆出了异常，所以我们的测试还没有结束 异常 他告诉我们NoSuchMethodException: com.java.Single.EnumSingle.(),就是说枚举类里没有空参的构造器\n此时我们进入Constructor这个构造器 在Constructor这个构造器，Instance里可以看出，正常应该报出\u0026ldquo;Cannot reflectively create enum objects\u0026rdquo;这个异常，即不能使用反射破坏枚举。所以我们的探究又失败了。\n失败2:\n经过上一次失败我们这次通过反编译将EnumSingle.class反编译回来\njavap -p EnumSingle.class\n反编译EnumSingle.class 此时我们看到里面也有一个空参的构造,说明我们还是被骗了\n成功:\n经过上面俩次被骗，此时使用一个更专业的工具Jad，用jad反编译EnumSingle.class\nJad(JAva Decompiler)是一个Java的反编译器，可以通过命令行把Java的class文件反编译成源代码。\n可以看出是一个有参构造，里面参数是一个string和int，那我们也把测试代码里的参数该成有参的在看看结果\n此时我们得倒了想要的结果，我宣布成功了\n","date":"2022-05-19T10:26:23+08:00","image":"/archives/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F2/1_hu4d45f9d8f7b84b7d44ef9aaa0a966809_426366_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F2/","title":"单例模式（2）"},{"content":"Java中单例(Singleton)模式是一种广泛使用的设计模式。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。\n单例模式好处:\n1.它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；\n2.能够避免由于操作多个实例导致的逻辑错误。\n3.如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。\n饿汉式 public class Hungry { private Hungry(){} //构造函数 private final static Hungry HUNGRY=new Hungry();//自己创建实例 // 通过该函数向整个系统提供实例 public static Hungry getInstance(){ return HUNGRY; } } 从代码中我们看到，类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。\n它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。\n它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。\n这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。 懒汉式 //懒汉式 public class Lazyman { private Lazyman(){}//构造函数 private static Lazyman lazyman;//不实例化 //通过该函数向整个系统提供实例 public static Lazyman getInstance(){ // 当 lazyman 为 null 时，则实例化对象，否则直接返回对象 if(lazyman==null){ lazyman =new Lazyman();//实例化 } return lazyman;//返回已经存在的对象 } 好处：懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。\n适用于：如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。\n缺点：但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题，实现如下: 当线程 A 进入到 if 判断条件后，开始实例化对象，此时 lazyman 依然为 null；又有线程 B 进入到 if 判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。\n所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们使用 Synchronized 同步锁来修饰 getInstance2 方法：\n// 懒汉模式 + synchronized 同步锁 //加了synchronized锁适用多线程，但效率不高 private Lazyman(){} private static Lazyman lazyman; public static synchronized Lazyman getInstance2(){ if(lazyman==null){ lazyman=new Lazyman(); } return lazyman; } 但同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。\n还有，每次请求获取类对象时，都会通过 getInstance2() 方法获取，除了第一次为 null，其它每次请求基本都是不为 null 的。在没有加同步锁之前，是因为 if 判断条件为 null 时，才导致创建了多个实例。基于以上两点，我们可以考虑将同步锁放在 if 条件里面，这样就可以减少同步锁资源竞争。\n你是不是觉得这样就可以了呢？答案是依然会创建多个实例。这是因为当多个线程进入到 if 判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁。所以我们还需要在同步锁里面再加一个判断条件.\n双重校验+锁（推荐） 这里使用到了volatile关键字，volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的，从而避免指令重排。\n// 懒汉模式 + synchronized 同步锁 + double-check private Lazyman(){} private volatile static Lazyman lazyman; public static Lazyman getInstance3(){ if(lazyman==null){ synchronized (Lazyman.class){ if(lazyman==null){ lazyman=new Lazyman();//不是一个原子性操作 /* * new对象的步骤（可能会发生指令重排，即执行顺序不是123，可能是132） * 1。分配内存空间 * 2。执行构造方法，初始化对象 * 3。把这个对象指向这个空间 * 如果是132，此时lazyman还没有完成构造，会认为lazyman!==null * 原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。 * */ } } } return lazyman; } 静态内部类（推荐） //懒汉式 静态内部类实现 public class Holder { private Holder(){ } private static Holder getInstance(){ return InnerClass.HOLDER;// 返回内部类中的静态变量 } //内部类实现 public static class InnerClass{ private static final Holder HOLDER=new Holder();//自己创建实例 } } 这种方式同样利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。\n不一样的是，它是在内部类里面去创建对象实例。\n这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。 枚举（强烈推荐） //enum本身就是一个class类 //枚举方式实现单例模式 //枚举类型是线程安全的，并且只会装载一次 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } //测试用例 class Test{ public static void main(String[] args) { EnumSingle instance1=EnumSingle.INSTANCE; EnumSingle instance2=EnumSingle.INSTANCE; System.out.println(instance1); System.out.println(instance2); } } 输出：\nINSTANCE\nINSTANCE\n可以看出俩个instance哈希值是一样的\n下面我们来看看单例是如何被保证的： 1.首先，在枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法。\n2.同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。 3.也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。\n单例模式的线程安全性 首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：\n（1）饿汉式：线程安全 （2）懒汉式：非线程安全 （3）双检锁：线程安全 （4）静态内部类：线程安全 （5）枚举：线程安全 如何选择 如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用； 如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到 jar 包，但未必会使用到这个工具类，懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源。 参考： https://blog.csdn.net/fly910905/article/details/79286680\n","date":"2022-05-19T08:26:57+08:00","image":"/archives/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1_huc1edc95ec616cac991cfea0a6834c461_267876_120x120_fill_q75_box_smart1.jpeg","permalink":"/archives/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"单例模式"},{"content":"Synchronized版生产者消费者问题（旧版） /* * 线程之间的通信问题：生产者消费者问题 等待唤醒 通知唤醒 * 线程交替执行 A B C D操作同一个变量 num=0 * A num+1 * B num-1 * C num+1 * D num-1 */ public class A { public static void main(String[] args) { Data data=new Data(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;C\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;D\u0026#34;).start(); } } //1判断等待，2业务，3通知 class Data{ private int number=0; //+1 public synchronized void increment() throws InterruptedException { while(number!=0){ //等待 this.wait(); } number++; System.out.println(Thread.currentThread().getName()+\u0026#34;=\u0026gt;\u0026#34;+number); //通知其他线程，我+1完了 this.notify(); } //-1 public synchronized void decrement() throws InterruptedException { while(number==0){ //等待 this.wait(); } number--; System.out.println(Thread.currentThread().getName()+\u0026#34;=\u0026gt;\u0026#34;+number); //通知其他线程，我-1完了 this.notify(); } } 如上执行后部分结果，可以看出不会出现不安全的问题： A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0\n如果将里面的while（）循环换成if就会出现安全问题（虚假唤醒），执行后如下,会出现有2的情况： A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 C=\u0026gt;2 D=\u0026gt;1 D=\u0026gt;0\n那为什么会出现这样的情况：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。\n这也就是为什么用while而不用if的原因了，因为线程被唤醒后，执行开始的地方是wait之后。\nLock版生产者消费者问题（新版） public class B { public static void main(String[] args) { Data2 data = new Data2(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.increment(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;C\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { try { data.decrement(); } catch (InterruptedException e) { throw new RuntimeException(e); } } },\u0026#34;D\u0026#34;).start(); } } //1判断等待，2业务，3通知 class Data2 { private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //+1 public void increment() throws InterruptedException { lock.lock();//有锁的话，先上锁 try { //业务代码 while (number == 0) { //等待 condition.await(); } number--; System.out.println(Thread.currentThread().getName() + \u0026#34;=\u0026gt;\u0026#34; + number); //通知其他线程，我-1完了 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock();//用完锁，要释放 } } //-1 public void decrement() throws InterruptedException { lock.lock(); try { while (number == 0) { //等待 condition.await(); } number--; System.out.println(Thread.currentThread().getName() + \u0026#34;=\u0026gt;\u0026#34; + number); //通知其他线程，我-1完了 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } 如上执行后部分结果，可以看出执行的结果是无序的：\nA=\u0026gt;1 B=\u0026gt;0 c=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 B=\u0026gt;0 A=\u0026gt;1 D=\u0026gt;0 c=\u0026gt;1\nLock版生产者消费者问题（新版改进） 那么接下来让他变成有序的（condition同步监视器），让线程被有序唤醒，而不是乱执行：\npublic class C { public static void main(String[] args) { Data3 data=new Data3(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { data.printA(); } },\u0026#34;A\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { data.printB(); } },\u0026#34;B\u0026#34;).start(); new Thread(()-\u0026gt;{ for (int i = 0; i \u0026lt; 10; i++) { data.printC(); } },\u0026#34;C\u0026#34;).start(); } } class Data3{ private Lock lock=new ReentrantLock(); //监视器 private Condition condition1=lock.newCondition(); private Condition condition2=lock.newCondition(); private Condition condition3=lock.newCondition(); private int number=1;// 1A,2B,3C public void printA(){ lock.lock(); try { //业务，判断-\u0026gt;执行-\u0026gt;通知 while (number!=1){ condition1.await(); } System.out.println(Thread.currentThread().getName()+\u0026#34;=\u0026gt;AAAAAA\u0026#34;); //唤醒指定的人，B number=2; condition2.signal();//唤醒指定线程 B } catch (Exception e) { throw new RuntimeException(e); } finally { lock.unlock(); } } public void printB(){ lock.lock(); try { //业务，判断-\u0026gt;执行-\u0026gt;通知 while (number!=2){ condition2.await(); } System.out.println(Thread.currentThread().getName()+\u0026#34;=\u0026gt;BBBBB\u0026#34;); //唤醒指定的线程C number=3; condition3.signal(); } catch (Exception e) { throw new RuntimeException(e); } finally { lock.unlock(); } } public void printC(){ lock.lock(); try { //业务，判断-\u0026gt;执行-\u0026gt;通知 while (number!=3){ condition3.await(); } System.out.println(Thread.currentThread().getName()+\u0026#34;=\u0026gt;AAAAAA\u0026#34;); //唤醒指定线程C number=1; condition1.signal(); } catch (Exception e) { throw new RuntimeException(e); } finally { lock.unlock(); } } } 执行部分结果如下，可以看出是有序执行，A-\u0026gt;B-\u0026gt;C：\nA=\u0026gt;AAAAAA B=\u0026gt;BBBBB C=\u0026gt;AAAAAA A=\u0026gt;AAAAAA B=\u0026gt;BBBBB C=\u0026gt;AAAAAA A=\u0026gt;AAAAAA B=\u0026gt;BBBBB C=\u0026gt;AAAAAA\n","date":"2022-04-29T12:50:22+08:00","image":"/archives/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/1_hu206ea868eb08867adbf59610251336c7_220185_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/","title":"生产者消费者问题"},{"content":"首先我们写一个报oom错误的代码\npublic class demo01 { public static void main(String[] args) { byte[] array=new byte[1*1024*1024];//1m 1兆 ArrayList\u0026lt;demo01\u0026gt; list=new ArrayList\u0026lt;demo01\u0026gt;(); int count=0;//计数 try{ while(true){ list.add(new demo01());//无限的向list中添加数据，new新的对象。注意：次方法会导致oom count=count++; } }catch(Error e){ System.out.println(\u0026#34;count:\u0026#34;+count); e.printStackTrace(); } //Throwable //error //Exception } } 设置堆内存大小 如果不设置堆内存，堆的默认内存应该是1GB，会占用很多资源 解释一下-XX:+HeapDumpOnOutOfMemoryError\nheap表示堆，on表示条件\n让堆进行Dump，条件是OutOfMemoryError。意思就是说只要报出OOM这个异常，就会被Dump\n如果要dump其他异常只需要将OutOfMemoryError这个异常改成你想要的dump的异常就可以了\nJprofiler查看内存使用情况 上一步我们设置完堆内存大小后，在运行一下程序，如下：会创建一个文件Dumping heap to java_pid47550.hprof \u0026hellip;。 此时我们找到这个文件：\n依次点击：对着demo01类右击\u0026gt;open in\u0026gt;finder\u0026gt;在文件根目录下就可以找到Dumping heap to java_pid47550.hprof这个文件,然后双击打开（前提是下载了jprofiler这个软件）\nJprofiler 如上图我们可以在最大对象这里看出是那个部分出错，如果具体要看是哪一行有问题，我们需要点击堆遍历器下的线程转储，这样就可以看出问题所在了\nJVM常见调优 堆设置\n-Xms:初始堆大小 -Xmx:最大堆大小 -XX:NewSize=n:设置年轻代大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxPermSize=n:设置持久代大小 收集器设置\n-XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器 -XX:+UseParalledlOldGC:设置并行年老代收集器 -XX:+UseConcMarkSweepGC:设置并发收集器 垃圾回收统计信息\n-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename 并行收集器设置\n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 ","date":"2022-04-24T20:10:48+08:00","image":"/archives/jprofiler%E7%9A%84%E4%BD%BF%E7%94%A8/1_huceec11a37ce81c6fc2bf176abd04b78c_215500_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/jprofiler%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Jprofiler的使用"},{"content":"java类加载器 首先，我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在Java中，类加载器有很多，那么当JVM想要加载一个.class文件的时候，到底应该由哪个类加载器加载呢？\n首先，我们需要知道的是，Java语言系统中支持以下4种类加载器：\nBootstrap ClassLoader (启动类加载器)\n默认加载的是jdk\\lib目录下jar中诸多类；\n这个路径可以使用 -Xbootclasspath参数指定。\nExtension ClassLoader (扩展类加载器)\n默认加载jdk\\lib\\ext\\目录下jar中诸多类；\n这个路径可以使用 java.ext.dirs系统变量来更改。\nApplication ClassLoader (应用程序类加载器)\n负责加载开发人员所编写的诸多类。\nUser ClassLoader (自定义类加载器)\n当存在上述类加载器解决不了的特殊情况，或存在特殊要求时，可以自行实现类加载逻辑。\n关系如图所示： 类加载器关系图 什么是双亲委派 其是在JDK1.2期间被引入的，而后陆续被推荐给开发者，到目前已经成为了最常用的类加载器实现方式了。 双亲委派整个过程分为以下几步：\n假设用户刚刚摸鱼写的Test类想进行加载，这个时候首先会发送给应用程序类加载器AppCloassLoader；\n然后AppClassLoader并不会直接去加载Test类，而是会委派于父类加载器完成此操作，也就是ExtClassLoader；\nExtClassLoader同样也不会直接去加载Test类，而是会继续委派于父类加载器完成，也就是BootstrapClassLoader；\nBootstrapClassLoader这个时候已经到顶层了，没有父类加载器了，所以BootstrapClassLoader会在jdk/lib目录下去搜索是否存在，因为这里是用户自己写的Test类，是不会存在于jdk下的，所以这个时候会给子类加载器一个反馈。\nExtClassLoader收到父类加载器发送的反馈，知道了父类加载器并没有找到对应的类，爸爸靠不住，就只能自己来加载了，结果显而易见，自己也不行，没办法，只能给更下面的子类加载器了。\nAppClassLoader收到父类加载器的反馈，顿时明白，原来爸爸虽然是爸爸，但是他终究不能管儿子的私事，所以这时候，AppClassLoader就自己尝试去加载。\n总结：就是一个类从应用类加载器（Application ClassLoader）进入，会不断的向上找类加载器直到找到类加载器的顶层-\u0026gt;启动类加载器（BootstrapClassLoader）,然后查看有没有对应的类，如果没有就交给子类去加载。\n为什么需要双亲委派机制 使用双亲委派模型，有一个很大的好处，就是避免原始类被覆盖的问题。\n比如，用户编写了一个Object类，放入程序中加载。\n当没有双亲委派机制时，就会出现重复的Object类，会给开发人员造成很大的困扰，本来就只需要基于JDK开发就好了，现在还得把JDK中的类全记住，避免编写重复的类。\n当存在双亲委派机制时呢，整个事情就不一样了，每次加载类时，都会遵循双亲委派机制，去问父类是否可以加载，如果可以呢，那就不需要再次加载了，这样事情就变得简单了。（老子走的路，小子不能走 ）\n另外，通过双亲委派的方式，还保证了安全性。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。\n那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。\n总结：1.避免类的重复加载\n2.防止核心类被篡改\n如何主动破坏双亲委派机制？ 首先看一下loadclass的源码：\nprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //首先检查类是否已经被加载过了 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); //若父加载器为空则默认使用启动类加载器作为父加载器 if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // 如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。 } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 看过源码我们知道了双亲委派模型的实现，那么想要破坏双亲委派机制就很简单了。\n因为他的双亲委派过程都是在loadClass方法中实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。\n总结：重写loadclass方法\n双亲委派被破坏的例子 第一种被破坏的情况是在双亲委派出现之前。\n由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。\n第二种，是JNDI、JDBC等需要加载SPI接口实现类的情况。\n第三种是为了实现热插拔热部署工具。为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。\n第四种时tomcat等web容器的出现。\n第五种时OSGI、Jigsaw等模块化技术的应用。\n","date":"2022-04-24T20:09:28+08:00","image":"/archives/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/1_hue76eed40a6aa8270cfd32ab6d790fcdd_71069_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","title":"双亲委派机制"},{"content":"什么是本地方法Native？ 简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以extern“C”告知C++编译器去调用一个C的函数。\n凡是带了Native关键字的，说明java的作用范围达不到了，会去调用底层c语言的库！\n“A native method is a Java method whose implementation is provided by non-java code.”\n在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。\n本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。\n举例\n如果要启动一个线程\nnew Thread.start(); 在start（）方法源码中\npublic synchronized void start() { if (threadStatus != 0)//状态校验 0：NEW 新建状态 throw new IllegalThreadStateException(); group.add(this);//添加进线程组 boolean started = false; try { start0();//调用native方法执行线程run方法 started = true; } finally { try { if (!started) { group.threadStartFailed(this);//启动失败，从线程组中移除当前前程。 } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); 进入start方法后，检查如果状态不为0，后将它添加到group组中，然后调用了一个start0（）方法，但是private native void start0(); 这个方法放在一个class会很奇怪吧。因为这是线程级别的东西，java处理不了然后去调用c++底层\n下面这张图：\njava虚拟机在操作系统之上，那操作系统的东西java是调用不了的，所以只能使用接口去调用本地方法，那调用本地方法库就需要使用到native\n为什么要使用Native Method？ Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。\n1.与java环境外交互：\n有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。\n你可以想想java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。\n2.与操作系统交互：\nJVM支持着Java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\n3.Sun\u0026rsquo;s Java\nSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。\nNative调用流程 本地方法接口（Java Native Interface）简称：JNI\n第一步：凡是带了Native关键字的，说明java的作用范围达不到了，会去调用底层c语言的库！\n第二步：进入本地方法栈区\n第三步：调用本地方法接口JNI\nJNI的作用:扩展java的使用，融合不同的语言为java所用 例如java调用python，c++等，都可以使用JNI\n那JNI为什么会诞生？\n因为java刚刚诞生的时候c和C++很流行，想要立足那必须要有可以调用c和c++程序\n一般在哪使用到Native？\n一般在做硬件方面的东西或者java程序驱动打印机，管理系统，robot（）机器人类\n","date":"2022-04-22T16:57:19+08:00","image":"/archives/jvm-native/1_hu3d03a01dcc18bc5be0e67db3d8d209a6_2551496_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/jvm-native/","title":"JVM Native"},{"content":"时间复杂度和空间复杂度是衡量算法优劣的标准，效率可以用算法的时间复杂度来描述，而所占用的存储空间可以用算法的空间复杂度来描述。\n时间复杂度：用于评估执行程序所消耗的时间，可以估算出程序对处理器的使用程度。 空间复杂度：用于评估执行程序所占用的内存空间，可以估算出程序对计算机内存的使用程度。 常见的时间复杂度有：O(1)常数型；O(log n)对数型，O(n)线性型，O(nlog n)线性对数型，O(n2)平方型，O(n3)立方型，O(nk)k次方型，O(2n)指数型。\n值得留意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效。这要添加上问题规模n的范围，在一定问题规范范围之前某一算法比另外一算法高效，而过了一个阈值之后，情况可能就相反了，通过上图我们可以明显看到这一点。这也就是为什么我们在实践的过程中得出的结论可能上面算法的排序相反的原因。\n如何推导时间复杂度 求解算法复杂度一般分以下几个步骤：\n找出算法中的基本语句：算法中执行次数最多的语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级：只需计算基本语句执行次数的数量级，即只要保证函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，使注意力集中在最重要的一点上：增长率。 用大Ο表示算法的时间性能：将基本语句执行次数的数量级放入大Ο记号中。 其中用大O表示法通常有三种规则： 用常数1取代运行时间中的所有加法常数；\n只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数； 下面通过具体的实例来说明以上的推断步骤和规则。 时间复杂度实例 常数阶O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：\nint i = 1; int j = 2; int k = 1 + 2; 上述代码执行时，单个语句的频度均为1，不会随着问题规模n的变化而变化。因此，算法时间复杂度为常数阶，记作T(n)=O(1)。这里我们需要注意的是，即便上述代码有成千上万行，只要执行算法的时间不会随着问题规模n的增长而增长，那么执行时间只不过是一个比较大的常数而已。此类算法的时间复杂度均为O(1)。\n对数阶O(log n) 先来看对应的示例代码:\nint i = 1; // ① while (i \u0026lt;= n) { i = i * 2; // ② } 在上述代码中，语句①的频度为1，可以忽略不计。\n语句②我们可以看到它是以2的倍数来逼近n，每次都乘以2。如果用公式表示就是122*2…*2 \u0026lt;=n，也就是说2的x次方小于等于n时会执行循环体，记作2^x \u0026lt;= n，于是得出x\u0026lt;=logn。也就是说上述循环在执行logn次之后，便结束了，因此上述代码的时间复杂度为O(log n)。\n其实上面代码的时间复杂度公式如果精确的来讲应该是：T(n) = 1 + O(log n)，但我们上面已经讲到对应的原则，“只保留时间函数中的最高阶项”，因此记作O(log n)。\n线性阶O(n) 示例代码：\nint j = 0; // ① for (int i = 0; i \u0026lt; n; i++) { // ② j = i; // ③ j++; // ④ } 上述代码中，语句①的频度为1，②的频度为n，③的频度为n-1，④的频度为n-1，因此整个算法可以用公式T(n)=1+n+(n-1)+(n-1)来表示。进而可以推到T(n)=1+n+(n-1)+(n-1)=3n-1，即O(n)=3n-1，去掉低次幂和系数即O(n)=n，因此T(n)=O(n)。\n在上述代码中for循环中的代码会执行n遍，因此它消耗的时间是随着n的变化而成线性变化的，因此这类算法都可以用O(n)来表示时间复杂度。\n线性对数阶O(nlogN) 示例代码：\nfor (int m = 1; m \u0026lt; n; m++) { int i = 1; // ① while (i \u0026lt;= n) { i = i * 2; // ② } } 线性对数阶要对照对数阶 O(log n)来进行理解。上述代码中for循环内部的代码便是上面讲到对数阶，只不过在对数阶的外面套了一个n次的循环，当然，它的时间复杂度就是n*O(log n)了，于是记作O(nlog n)。\n平方阶O(n²) 示例代码:\nint k = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { k++; } } 平方阶可对照线性阶来进行理解，我们知道线性阶是一层for循环，记作O(n)，此时等于又嵌套了一层for循环，那么便是n * O(n)，也就是O(n * n)，即O(n^2)。\n如果将外层循环中的n改为m，即：\nint k = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { k++; } } 那么，对应的时间复杂度便为：O(m * n)。\n同理，立方阶O(n³)、K次方阶O(n^k)，只不过是嵌套了3层循环、k层循环而已。\n空间复杂度 最后，我们再了解一下空间复杂度。空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量，这里的空间复杂度同样是预估的。\n程序执行除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间。存储空间通常包括：指令空间（即代码空间）、数据空间（常量、简单变量）等所占的固定部分和动态分配、递归栈所需的可变空间。其中可变空间与算法有关。\n一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))其中n为问题的规模，S(n)表示空间复杂度。\n空间复杂度实例 空间复杂度 O(1) 空间复杂度为O(1)的情况的示例代码与时间复杂度为O(1)的实例代码一致：\nint i = 1; int j = 2; int k = 1 + 2; 上述代码中临时空间并不会随着n的变化而变化，因此空间复杂度为O(1)。总结一下就是：如果算法执行所需要的临时空间不随着某个变量n的大小而变化，此算法空间复杂度为一个常量，可表示为 O(1)，即 S(n) = O(1)。\n空间复杂度 O(n) 示例代码：\nint j = 0; int[] m = new int[n]; for (int i = 1; i \u0026lt;= n; ++i) { j = i; j++; } 上述代码中，只有创建int数组分配空间时与n的大小有关，而for循环内没有再分配新的空间，因此，对应的空间复杂度为S(n) = O(n)。\n总结：\n本篇文章给大家讲了可以通过时间复杂度和空间复杂度来衡量算法的优劣，同时用具体的实例来讲解如何计算不同方法的时间复杂度和空间复杂度。\n参考：\nhttps://blog.csdn.net/zolalad/article/details/11848739\n","date":"2022-04-08T13:51:19+08:00","image":"/archives/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/2_hufa17463cd2f8fec8fc68f7767c4d536f_109577_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"时间与空间复杂度"},{"content":"关于快慢指针 怎么证明快慢指针在环中是可以相遇的？ 证明这个问题？可能你会说，只要快慢两个指针都进入环中，两者有速度差，快指针就一定能够追上慢指针。可是这儿“追上”有可能是两种情况（注意，这儿讨论的是一般情况，快指针步长k \u0026gt;= 2），一是恰好追上（也就是相遇了），二是追上并超过了慢指针。当然，这两种情况都不妨碍我们判断是否有环存在。下面我们就证明一下无论快指针步长k为多少，快慢指针在环中都能恰好相遇。\n证明开始：\n方法一： 链表图 首先，换个角度想问题。用一个步长为1的指针模拟遍历这个单向链表的过程。如上图所示，设单向链表的起始结点为X0（0是下标），环的起始结点为Xs。自然，遍历到最后就是一遍遍的重复这个环。如果，我们把遍历的项都不断记录到一个数组中的话(下标按次序递增)，最后就是一定长度的序列串的重复。例如，\nX0, X1, \u0026hellip; , Xs, Xs+1, \u0026hellip;, Xs+cl-1\n​ Xs+cl, Xs+cl+1, \u0026hellip;, Xs+2*cl-1\n​ \u0026hellip;\ncl (circle length)表示环的长度。\n假设 j 是 cl 的整数倍，并且是 cl 整数倍中满足 j \u0026gt; s 最小的那个数。对于任意的 k (k \u0026gt;= 2)，我们考虑下标分别为 j 和 jk 的两个位置 Xj 和 Xjk。可见，Xj 就是慢指针走了 j 步之后的位置，而 j \u0026gt; s 则保证了此时慢指针已经进入环中。同理，此时的快指针在位置 Xjk，必然也在环中。\n因为 j 是 cl 的整数倍，我们可以把 Xjk 看成是一个指针从位置 Xj 开始，走了 (k - 1) 次的 j 步。而每走 j 步，在单向链表的环中，其实又回到了 Xj 位置，因为 j 是 cl 的整数倍。所以我们有，Xj = Xjk 。这样，我们就证明了快慢指针肯定会恰好相遇的问题。\n为什么快指针步长要为 2 ？3，4，5可以吗 有了上面证明的基础，就不难发现 k 越小，所需的遍历次数就越少，因为给定一个带环的单向链表，j 的取值是确定的。所以，取 k ＝ 2。当然，除了 1 ，别的其他数都可以。\n正规一点儿的分析，如下：\n因为 j 是 cl 的整数倍，并且是 cl 整数倍中满足 j \u0026gt; s 最小的那个数。如果 s \u0026lt;= cl，那么 j = cl；如果 s \u0026gt; cl，那么 j \u0026lt; 2*s ，所以 j 的时间复杂度为 O(s + cl)。假设单向链表中结点的个数为 n，因为 s 和 cl 都是小于 n 的，所以 j = O(n) 。这是慢指针的时间复杂度，那么快指针的就是 O(nk) 。所以取 k = 2 ，可以最小化算法的运行时间。\n方法二(简单版)： 证明能相遇 假定环前节点有 x 个，环上节点有 y 个，快慢指针在环上分别走了 m，n 圈后相遇， 在环上相遇的位置为 z，用 i 表示慢指针在相遇的时候走了多少步。能有如下两表达式： x + my + z = 2*i + 1 x + ny + z = 1*i 两式相减 (m - n)y = (2-1)i + 1 说明 i+1 的值为环节点长度的倍数，即可相遇 为什么快指针步长要为 2 ？3，4，5可以吗 有了上面证明的基础，就不难发现 k 越小，所需的遍历次数就越少，因为给定一个带环的单向链表，j 的取值是确定的。所以，取 k ＝ 2。当然，除了 1 ，别的其他数都可以。\n正规一点儿的分析，如下：\n因为 j 是 cl 的整数倍，并且是 cl 整数倍中满足 j \u0026gt; s 最小的那个数。如果 s \u0026lt;= cl，那么 j = cl；如果 s \u0026gt; cl，那么 j \u0026lt; 2*s ，所以 j 的时间复杂度为 O(s + cl)。假设单向链表中结点的个数为 n，因为 s 和 cl 都是小于 n 的，所以 j = O(n) 。这是慢指针的时间复杂度，那么快指针的就是 O(nk) 。所以取 k = 2 ，可以最小化算法的运行时间。\n总结：取其他数可以，但每取大一倍数就得多走一圈，所以取2才是最优解。\n参考：\nhttps://blog.csdn.net/xgjonathan/article/details/18034825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.not_use_machine_learn_pai\n","date":"2022-04-07T14:20:13+08:00","image":"/archives/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/1_hu41d61907f311ce5b0ea210fd61a4a533_75291_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","title":"快慢指针"},{"content":"1. Java中的泛型是什么 ? 使用泛型的好处是什么? 原则是什么？ Java泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常。\nJava泛型设计原则：只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常。\n泛型，即“参数化类型”，把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊类型,把\u0026lt;数据类型\u0026gt;当作是参数一样传递\n好处,在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。\n2. Java的泛型是如何工作的 ? 什么是类型擦除 ? 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。\n//类型被擦除了，保留的是类型的上限，String的上限就是Object List list = strlist; ​ List\u0026lt;String\u0026gt; stringList2 = list; List\u0026lt;Integer\u0026gt; intList2 = list; //你也可以把它赋给Integer类型的集合，但是当你把这个集合当 //成Integer的集合操作的时候，依旧会抛出ClassCastException异常 ​ for (Integer i:intList2){//java.lang.ClassCastException System.out.println(i); } 3. 什么是泛型中的限定通配符和非限定通配符 ? 限定通配符对类型进行了限制。有两种限定通配符，一种是\u0026lt;? extends T\u0026gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是\u0026lt;? super T\u0026gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面\u003c?\u003e表示了非限定通配符，因为\u003c?\u003e可以用任意类型来替代。\npublic class Animal { public static void main(String[] args) { ArrayList\u0026lt;Animal\u0026gt; animals=new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Cat\u0026gt; cats=new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;? extends Cat\u0026gt; miniCats=new ArrayList\u0026lt;\u0026gt;(); showAnimal(cats); showAnimal(miniCats); //showAnimal(animals); } //类型通配符的上限，要求该泛型的类型，只能是实参类型，或实参类型的子类类型。 //此处上限是Cat，包括MiniCat但是不包括Anmial的 public static void showAnimal(ArrayList \u0026lt;? extends Cat\u0026gt; list){ for (int i = 0; i \u0026lt; list.size(); i++) { Cat cat = list.get(i); System.out.println(cat); } } //要求该泛型的类型，只能是实参类型，或实参类型的父类类型。 //类型通配符的下限，要求只能是Cat或者是Cat的父类 public static void showAnimal2(List\u0026lt;? super Cat\u0026gt; list){ //增强for循环，用object类型的o接受，遍历list for (Object o : list) { System.out.println(o); } } } class Cat extends Animal{ } class MiniCat extends Animal{ } 4.可以把List\u0026lt; String\u0026gt;传递给一个接受List \u0026lt; Object\u0026gt;参数的方法吗？ 对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以List\u0026lt; String\u0026gt;应当可以用在需要List\u0026lt; Object\u0026gt;的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List\u0026lt; Object\u0026gt;可以存储任何类型的对象包括String, Integer等等，而List\u0026lt; String\u0026gt;却只能用来存储Strings。\n例一:\n//这里与 List\u0026lt;Object\u0026gt; objectList; List\u0026lt;String\u0026gt; stringList; objectList = stringList; //compilation error incompatible types 例二:\nList list = new ArrayList();//默认类型是Object list.add(\u0026#34;A123\u0026#34;); list.add(\u0026#34;B234\u0026#34;); list.add(\u0026#34;C345\u0026#34;); System.out.println(list); for(int i=0;i\u0026lt;list.size();i++){ //若要将list中的元素赋给String变量，需要进行类型 //转换compatible types错误，显示list.get(i)返回的是Object String str = (String) list.get(i); System.out.println(str); } ​ list.add(123); //因为类型是Object，我们可以把Integer类型或者其他数据类型的元素也加入list之中 System.out.println(list.get(3)); ​ for(int i=0;i\u0026lt;list.size();i++){ //String str = (String) list.get(i); //但是在这里会报错java.lang.ClassCastException， //我们不能直接将Integer类型的数据转换成String System.out.println(list.get(i).getClass()); } 如代码中所示，当我们定义了一个List，list默认的类型是所有对象的基类Object，那么我们取出数据的时候需要经过一次类型转换才能进行对象的实际类型的相关操作。因为List中的类型是Object，那么我们先添加了String类型的数据，然后再添加Integer或者其他类型的数据也是允许的，因为编译时List中是Object类型的数据，然而运行的时候却是它本身的类型，所以当我们将List中的数据当作String处理时会抛出java.lang.ClassCastException\n5. Array中可以用泛型吗? 这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。\n本文参考：\nhttps://www.jb51.net/article/214509.htm\nhttps://cloud.tencent.com/developer/article/1033693\n","date":"2022-03-14T10:29:23+08:00","image":"/archives/%E6%B3%9B%E5%9E%8B/1_hu4e960fdb6340cae1ad375241e2cdb7c4_2583790_120x120_fill_box_smart1_3.png","permalink":"/archives/%E6%B3%9B%E5%9E%8B/","title":"泛型"},{"content":"GPG介绍 提到 GPG 不得不提一下 PGP(Pretty Good Privacy) ， PGP 最开始是由 Phil Zimmermann 开发，开发的目的是为了躲避监视，如果文件在网络上明文传输，那是多么危险。 PGP 虽然受很多人喜爱，但是是个商业软件，不能自由使用。所以自由基金会决定自己开发一个取名叫 GPG ，这就是 GPG 的由来。 GPG 和 PGP 都遵循 OpenPGP 加解密标准， 现在 PGP 被赛门铁克公司收购了。\n我们平时用各个网站免不了要记住密码，但如果都用一个那风险就很高，如果每个网站都不一样，那也记不住。通常的做法是把这些密码存到一个文件里，但是这个文件本身的安全我们没法保证，所以我们需要对这个文件进行加密。这就要用到我们今天的主角 GPG\n安装 安装就非常简单，没什么好说的，执行命令就完成了。我的是通过二进制文件下载的中文版，如果是brew下载应该是英文的，本文以英文版的为教程（中文的我就不多bb了）\nMac brew install gpg 生成密钥 现在我们通过 gpg --full-gen-key 来生成密钥。 密钥生成 Your selection? (选择要使用的加密算法),选1就行了\nRSA keys may be between 1024 and 4096 bits long,(选择加密算法的长度，默认是2048，我选了最长的 4096)\nPlease specify how long the key should be valid.(选择密钥过期时间，如果是自己使用的话，可以选择永不过期，此处我选的0)\nReal name:(输入用户名，不能少于5个字符，随便写自己喜欢的名字就行了)\nEmail address(输入自己的邮箱)\nComment:(这个可以不写，直接回车)\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O(如果确认无误，输入 O)\n通过上面的操作，生成了一个名为 lsygpg ，使用 RAS 算法加密，并且永不过期的账户。\n你如果不想选择加密算法和长度信息，可以使用 gpg --gen-key 来快速生成。这样生成的默认算法是 RAS ，有效时间是一年， comment 为空。\n生成撤销密钥 生成完密钥之后，为了保险起见，我们需要生成一个撤销证书，以便在日后我们不使用这个密钥的时候可以撤销。\n这个撤销只有你把公钥上传到公钥服务器才有效，如果你不上传到公钥服务器其实没多大作用。即便申请撤销了，它还是会存在，只是不建议使用了。\n撤销的命令如下\ngpg --gen-revoke test1 加密 有了密钥之后，我们来看看怎么用它来加密一个文件\n通过 gpg -r [uid] -o file -e file 来加密一个文件，其中 -r 指定用哪个用户加密， -o 表示加密后输出的文件， -e 表示要加密的文件。如果不用 -o 默认会在原来的文件后面添加 .gpg 的后缀，用来表示加密文件。\n举个例子：假设我们有一个 test.txt 的文件，内容如下\n我是帅哥 我们对其进行加密\ngpg -r test1 -e test.txt -- 可以使用 gpg -r test1 -o test.txt.gpg -e test.txt 效果是一样的 执行完成后会得到一个名为 test.txt.gpg 的文件，这个文件是一个二进制文件。\n如果我们想要显示 ASCII ，可以通过添加 -a 来显示\n密钥生成 解密 加密完之后，我们来看如何解密\n通过 gpg -o file -d file 来对文件进行解密，其中 -o 表示解密后输出的文件，要放在前面， -d 表示要解密的文件。\n我们就拿之前加密的文件来进行解密\ngpg -o decrypt.txt -d test.txt.gpg cat decrypt.txt 我是帅哥 gpg -o decrypt.txt -d test.txt.asc cat decrypt.txt 我是帅哥 解密的时候会让你输入密码 密钥生成 签名 二进制签名 GPG除了可以用来加密，还可以用来签名，比如在 Github 上可以添加公钥来表示这个代码确实是你提交的。\n使用 gpg --sign test.txt 对 test.txt 进行签名，生成 test.txt.gpg ，里面的内容是二进制。\nASCII 签名 除了二进制的方式还可以输出 ASCII 的签名，用 gpg --clearsign test.txt 对 test.txt 进行 ASCII 签名\ngpg --clearsign test.txt cat test.txt.asc -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA256 This is gpg test -----BEGIN PGP SIGNATURE----- iQIzBAEBCAAdFiEEiPHq0DgY+8QbgkHmOxWoUusKglEFAl41jDIACgkQOxWoUusK glFEKhAAqwzhd4lexf1KyMTuCd5jAftPGB6AC1igmUx0gjpnMoZHv7gJkfFr8jTa iD958jXVY4fawsBQ+LEEkpJarBdZfY2No5Dw1PSlRlaUzCQgMkOPgLTdqGHuTNB0 /ENsIiweXv5kUXiSU1Paxedwi7yux5L34WWdi9Mg9KoLhJN84HEdzIKYZjJNyFtB WYP/Nqqqs01SBa3writrdVaj/ZaDqMtpzM9DSxfMT4P6NVDR3RGSTkQpnatEEa67 11i+oQXQcQT6a+O1vZ8GwbfoQ/EmPGT4nURs1HSEbAXj2aInquU5UjIvkvDp3q2x j9UbDBcQaQWQdAsuJItIfLeyY1BhejqVIjhPPFMhplp5XrHMMR+JJXOUJleQkkZV q35RitRlnRCjm+Z26aACS1vSS4Y23jaNV+MWv23OF570+iQ1lVotYLeLeMbuW4s9 oWQIqJydaePbL87wR3tTWm7OjlgZNrrSXh9aH366Oz5tjZVrZoJwNDupOj5uAgsf T58N0St0OlrPO2csUQw5Kkd7Ls1lKCkh+drPQEPHJJODzNo4WxjtPGwgwhIhLJcw o1TQxd3h5YhVInCs0XFzSx3Ty/Ds0Lm0zFa4AyINl0QiHkQy2OoD4rsFO7n6LdOk zJKrFEkSwuvTOeIBUOGulwZiZEFrxb9KpaCjhMLZgQfjSYAnyQ8= =lmwE -----END PGP SIGNATURE----- 这种方式会在源文件里加上签名。\n","date":"2022-01-31T13:42:39+08:00","image":"/archives/gpg%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%9B%E5%BB%BA/1_hu6953af31534abddeef4516176bce74a2_454934_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/gpg%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%9B%E5%BB%BA/","title":"GPG的使用与创建"},{"content":"前言 之前在购买 VPS 和域名时发现很多国外商家只支持 VISA，MASTERCARD 这两家的信用卡或者 PayPal，虽然国区 PayPal 可以绑定银联的借记卡/信用卡，但是除了这些以外我还有在 Google Play 购物的需求，未来也会有更多的境外支付的需要，目前我已经忍受不了每次去 Google Play 购物时都要先去淘宝买个礼品卡这个操作了，所以决定采用一个一劳永逸的办法：办理一张外币信用卡（准确来说是走非银联结算通道的信用卡）。我原本以为作为大学生办理一张外币信用卡会比较麻烦，不过想到之前在少数派看过《给普通大学生的境外支付指南》和《学生党 Google Play 剁手经验分享》，所以决定照此进行尝试。PS：本文都是我的个人经验分享，不一定完全有效，同时也可能具有时效性，仅作参考。\n大学生申请外币信用卡的方法 按照我的估计，很多大学生都没有考虑过申请信用卡，日常消费只需要借记卡绑定微信支付和支付宝就没问题了，有关于信用卡与借记卡的区别，是否应该申请信用卡，google 一下就能找到不少靠谱的回答，我就不多说了。不过大约十几年前大学生申请信用卡真的很难，由于申请信用卡时需要经过银行的资产审核，而大学生又没有工作，所以对于很多大学生来说是几乎不可能申请到信用卡。不过近年来已经有相当多的银行推出了大学生专属信用卡，上述的问题已经不复存在。然而别以为随便申请一张大学生信用卡就可以在 Google Play 之类的国外商店上购物了，想要在 Google Play 上购物，你需要一张非银联的信用卡（借记卡也行，但我只记得中国银行的 EMV 卡属于这一类）。注意，必须是非银联的卡，因为很多国外付款方式都不支持银联。除此以外，借记卡/信用卡还有单币/双币/全币的区别，只不过 VISA 和 MASTERCARD 基本上都是使用美元结算的，所以我们几乎不需要关心这个差别。在满足非银联的这个条件下，我们来选择一间银行的信用卡，参考学姿势的《大学生信用卡申请姿势》，里面对比了各个银行的大学生信用卡的区别，我们主要关注的是是否有 VISA 或 MasterCard 等非银联的卡，当然我也建议最好看下学姿势的其它文章，以后想要靠信用卡享受各种福利（俗称薅羊毛）的话可先要熟悉各家银行的信用卡的区别哦。\n以我申请的民生银行 more 世界卡为例，我先参考了《民生银行大学生信用卡申请指引》，然后通过民生银行官网进行申请（请注意是否为大学生版，大学生版是不需要填职业等信息的，如果不确定的话，点击学姿势的民生银行学术卡申请通道），在申请页面上如实填写必填的个人信息，在这当中，亲属手机号应该是最麻烦的，因为银行会根据这个手机号给你的家长发送短信，如果你的家长不同意你办信用卡，那么这里提供两个办法：\n1.假如你有一个手机号是你的家长的手机号的附属号码，那可以直接填这个手机号，然后在本人手机号填入一个使用自己的身份证注册的手机号。\n2.在家长的手机上设置短信骚扰拦截（每个国内 ROM 应该都有这个功能吧），根据短信内容设置关键字，短信的具体内容可看下方，例如可以设置拦截“民生银行”。\n【民生银行】尊敬的A，您好！您的亲属B已向民生银行提交信用卡申请，我行预审通过，预计为其核发卡片的信用额度为5000.00元，具体申请事宜请您联系申请人核实。如您对本次申请存在异议，请于Y年M月D日24点前短信回复“QXSQ”，我行将终止本次申请。超过上述时间未回复则视为您同意本次申请。感谢您的支持！\n搞定这些麻烦的申请步骤后，就是等待银行进行资料审核了。不出意外的话，大约一个星期后你就能收到通过信用卡申请的短信，假如不幸被拒的话，请回忆下自己是否填错了一些个人信息，或者之前是否曾有过欠钱没还的不良行为（例如花呗忘了还），或者学校不在某些银行的白名单当中。\n在发送短信告诉申请者通过信用卡申请后，银行会通过邮寄方式将信用卡寄给申请者，稍微等个两天，信用卡就到了！\n不过很可惜的是，刚到手的信用卡还不能被使用，需要进行激活后才可正常使用，有一些银行可以网上激活，然而民生银行是要求持卡人必须到柜台进行当面激活的，假如你在比较偏远的城市，这个就不太好办了。另外，我很想吐槽一下民生银行的初始信用卡密码设置手续，这 TM 居然需要我打电话进行设置，就完全没有考虑过安全性的问题吗？信用卡激活后，申请信用卡的整个过程总算是结束了，恭喜各位打开了新世界的大门。\n外币信用卡到手后 既然有了外币信用卡，那么很多国外商家的大门已经对我们敞开了。Google Play，美区 App Store，美区/日区亚马逊等商店都可以让我们疯狂剁手，还可以订阅 Spotify，Netflix 等流媒体服务。读到这里的读者可能都没有使用信用卡购物的经验，不过没关系，使用外币信用卡购物并不麻烦，一般而言只需填入信用卡卡号，CVC 码（信用卡背面的一个三位数），有效日期就可以了，以 Google Play 为例，说一下如何添加外币信用卡作为付款方式。\n在Google Play上添加外币信用卡作为付款方式 与申请信用卡相比，这节内容可以说是简单多了，直接根据图片操作即可（我已经添加了付款地址，如果之前尚未添加，那么在要求输入付款地址时可以随便输入相关信息，亲测姓名和地址等信息可以与信用卡上的信息不同；另外，确保信用卡里有大于等于 1 美元的余额/额度）：\n1.打开 Google Play，在侧边栏找到“付款方式”并点击\n付款方式 2.点击“添加信用卡或借记卡”，按照要求输入信用卡卡号，CVC 码，有效日期（别填错了！！！）等\n添加信用卡或借记卡 3.假如一切顺利的话，现在即可使用信用卡在 Google Play 上购买东西了，出现问题的话可参考《学生党 Google Play 剁手经验分享》中的“添加卡片并购物”一节进行解决，懒得与客服沟通的话可以先试着申请美区 PayPal 帐号，然后选择美区 PayPal 作为付款方式。\n一些小贴士 1.可以考虑使用外币信用卡申请美区 PayPal 帐号，使用 Paypal 付款更安全。 2.请善用 Google Play 中的心愿单功能，不急着买但想买的东西可放入心愿单中，等待打折，在黑色星期五的时候，很多 App 都会有幅度非常大的折扣。 3.外币信用卡建议设置自动购汇还款，一般在银行 App 中可设置此项，能免去每月手动购汇还款的麻烦，而且不用担心自己忘了还款。\n4.记得还款，各家银行的最后还款期限不尽相同，在每个月的最后还款期限前请确认一下自己是否已还款。\n5.再次强调，请注意用卡安全，信用卡背面的信息不要随便泄漏给别人。\n","date":"2021-12-17T00:00:00Z","image":"/archives/%E4%BD%9C%E4%B8%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%9A%84%E6%88%91%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E5%A4%96%E5%B8%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%B9%B6%E7%94%A8%E4%BA%8E%E5%A2%83%E5%A4%96%E6%94%AF%E4%BB%98/show_hua1e96627c79bb7cd39936a6d63fa6003_596890_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E4%BD%9C%E4%B8%BA%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%9A%84%E6%88%91%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E5%A4%96%E5%B8%81%E4%BF%A1%E7%94%A8%E5%8D%A1%E5%B9%B6%E7%94%A8%E4%BA%8E%E5%A2%83%E5%A4%96%E6%94%AF%E4%BB%98/","title":"作为大学生的我如何申请外币信用卡并用于境外支付"},{"content":"初始化 输入命令：\nmkdir \u0026lt;项目名称\u0026gt; cd \u0026lt;项目名称\u0026gt; #进入目录 git init #初始仓库，新建一个 .git 目录 ls -la #查看所有文件 touch \u0026lt;file1\u0026gt; #创建一个文件 mkdir \u0026lt;dir1\u0026gt; #新建一个目录 现在可以修改文件内容\ngit status -sb #文件前面有 ?? 号 git add . #一次性将文件添加到暂存区 git status -sb #现在文件前面 ?? 变成了 A git commit -m \u0026#34;xx\u0026#34; #将你 add 过的内容正式提交到本地仓库，并添加注释 git log #查看历史变动 文件变动 git status -sb git add . git commit -m \u0026#34;xx\u0026#34; 将本地仓库上传到 GitHub 新建一个空仓库，名称与本地目录名一致，复制ssh 不需要勾选任何东西\ngit remote add origin git@github.com:xxxx/\u0026lt;仓库名\u0026gt; git push -u origin master 更改文件内容 git add . git commit -m \u0026#34;xx\u0026#34; git push ","date":"2021-11-14T20:58:22+08:00","image":"/archives/%E4%BD%BF%E7%94%A8git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/p2_huf0460c7f5de3c9d4790db75b7f8c7413_373707_120x120_fill_q75_box_smart1.jpg","permalink":"/archives/%E4%BD%BF%E7%94%A8git%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","title":"使用git创建版本库"}]